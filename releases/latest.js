"use strict";var k=Object.defineProperty;var I=(e,o,t)=>o in e?k(e,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[o]=t;var O=(e,o,t)=>I(e,typeof o!="symbol"?o+"":o,t);const C=require("lodash"),l={mining:"⛏️",harvesting:"⛏️",picking:"⛏️",withdrawing:"📥",waiting:"⏳",transferring:"🔄",receiving:"📥",full:"🛑",building:"🚧",upgrading:"⚡",repairing:"🔧"},y=(e,o,t={})=>{const{time:r=Game.time}=t;r%e===0&&o()};var g=(e=>(e.MainBase="Spawn1",e))(g||{}),_=(e=>(e.MainRoom="E49S54",e))(_||{});Object.values(g);const S={getVisualStatus:e=>{var r;const o=e.fatigue,t=`${(r=e.memory.role)==null?void 0:r.slice(0,3)} ${o>0?o:""}`;return e.room.visual.text(t,e.pos.x,e.pos.y-1,{font:.5,color:"#00ff00",stroke:"#000000",strokeWidth:.1})},create:e=>{var i,f;const{baseId:o=g.MainBase,body:t,name:r,role:n,opts:u}=e,R=r!=null?r:`${n}-${Game.time}`;return(f=(i=Game.spawns)==null?void 0:i[o])==null?void 0:f.spawnCreep(t,R,C.merge({memory:{role:n}},u))}},E=e=>e.reduce((o,{body:t,count:r})=>o.concat(Array(r).fill(t)),[]),A=(e,o,t=1)=>{var f,a;const r={},n=Game.rooms[_.MainRoom];if(!n)return[];const u=[{x:e,y:o}],R=new Set;for(;u.length>0;){const s=u.pop();if(R.has(`${s.x}-${s.y}`))continue;R.add(`${s.x}-${s.y}`);const c=n.lookAtArea(s.y-t,s.x-t,s.y+t,s.x+t,!0).filter(m=>(m==null?void 0:m.terrain)!=="wall"&&m.type!=="source");for(const m of c)if((m==null?void 0:m.type)==="creep"&&m.creep){const d=Game.creeps[(f=m.creep)==null?void 0:f.name];["miner","minerStore"].includes((a=d.memory.role)!=null?a:"")&&u.push({x:m.x,y:m.y})}else R.add(`${m.x}-${m.y}`),r[`${m.x}-${m.y}`]?r[`${m.x}-${m.y}`].push(m):r[`${m.x}-${m.y}`]=[m]}const i=[];return Object.entries(r).forEach(([s,c])=>{if(new Array(...new Set(c)).every(d=>!["creep","structure"].includes(d.type))){const[d,T]=s.split("-");i.push({x:Number(d),y:Number(T)})}}),i};function v(e,o,t){return o==="MinerStore"?t?e.pos.findClosestByRange(FIND_MY_CREEPS,{filter:r=>r.memory.role==="minerStore"&&r.store[RESOURCE_ENERGY]>0}):e.room.find(FIND_MY_CREEPS,{filter:r=>r.memory.role==="minerStore"&&r.store[RESOURCE_ENERGY]>0}):["container","storage"].includes(o)?t?e.pos.findClosestByRange(FIND_MY_STRUCTURES,{filter:r=>["storage","container"].includes(r.structureType)&&r.store.getFreeCapacity(RESOURCE_ENERGY)>0}):e.room.find(FIND_MY_STRUCTURES,{filter:r=>["storage","container"].includes(r.structureType)&&r.store.getFreeCapacity(RESOURCE_ENERGY)>0}):["mineral","source"].includes(o)?t?e.pos.findClosestByRange(FIND_STRUCTURES,{filter:r=>r.structureType===o}):e.room.find(FIND_STRUCTURES,{filter:r=>r.structureType===o}):o==="ruin"?t?e.pos.findClosestByRange(FIND_RUINS,{filter:r=>r.store[RESOURCE_ENERGY]>0}):e.room.find(FIND_RUINS,{filter:r=>r.store[RESOURCE_ENERGY]>0}):o==="tombstone"?t?e.pos.findClosestByRange(FIND_TOMBSTONES,{filter:r=>r.store[RESOURCE_ENERGY]>0}):e.room.find(FIND_TOMBSTONES,{filter:r=>r.store[RESOURCE_ENERGY]>0}):o==="resource"?t?e.pos.findClosestByRange(FIND_DROPPED_RESOURCES,{filter:r=>r.amount>0}):e.room.find(FIND_DROPPED_RESOURCES,{filter:r=>r.amount>0}):null}const b=[STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_CONTAINER,STRUCTURE_STORAGE],G=(e,o)=>{var t;if(e.memory.task==="transferring"){if(e.store[RESOURCE_ENERGY]===0){e.memory.task="harvesting";return}const r=e.room.find(FIND_STRUCTURES,{filter:n=>b.includes(n.structureType)&&"store"in n&&n.store.getFreeCapacity(RESOURCE_ENERGY)>0}).sort((n,u)=>{const R=b.indexOf(n.structureType),i=b.indexOf(u.structureType);return R-i});r.length>0&&e.transfer(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0],{visualizePathStyle:{stroke:"#ffffff"}});return}if(e.store.getFreeCapacity()===0){e.memory.role==="harvester"&&(e.memory.task="transferring");return}if(e.store[RESOURCE_ENERGY]===0&&e.memory.task!=="harvesting"){e.memory.task="harvesting";return}if(e.store.getFreeCapacity()>0&&e.memory.task==="harvesting"){if(e.memory.role!=="harvester"){const a=e.room.find(FIND_STRUCTURES,{filter:s=>s.structureType===STRUCTURE_CONTAINER&&s.store[RESOURCE_ENERGY]>e.store.getFreeCapacity()});if(a.length>0)if(e.pos.isNearTo(a[0])){e.withdraw(a[0],RESOURCE_ENERGY)===OK&&e.say(l.receiving);return}else{e.moveTo(a[0],{visualizePathStyle:{stroke:"#ffaa00"}});return}}const n=Object.values(Memory.sources.Source).map(a=>Game.getObjectById(a)).reduce((a,s)=>{var c,m,d,T;return s instanceof Source&&s.energy>0?a.Source=[...(c=a.Source)!=null?c:[],s]:s instanceof Resource&&s.amount>0?a.Resource=[...(m=a.Resource)!=null?m:[],s]:s instanceof Tombstone&&s.store[RESOURCE_ENERGY]>0?a.Tombstone=[...(d=a.Tombstone)!=null?d:[],s]:s instanceof Ruin&&s.store[RESOURCE_ENERGY]>0&&(a.Ruin=[...(T=a.Ruin)!=null?T:[],s]),a},{Source:[],Resource:[],Tombstone:[],Ruin:[]});if(n.Resource.length>0){const a=n.Resource[0],s=e.pickup(a);s===OK?e.say(l.harvesting):s===ERR_NOT_IN_RANGE&&e.moveTo(a,{visualizePathStyle:{stroke:"#ffaa00"}});return}if(e.memory.role!=="harvester"&&(n.Tombstone.length>0||n.Ruin.length>0)){const a=(t=n.Tombstone[0])!=null?t:n.Ruin[0],s=e.withdraw(a,RESOURCE_ENERGY);s===OK?e.say(l.harvesting):s===ERR_NOT_IN_RANGE&&e.moveTo(a,{visualizePathStyle:{stroke:"#ffaa00"}});return}if(e.memory.role!=="harvester"||e.memory.role==="harvester"&&(o==null?void 0:o.priority)==="high"){const a=e.pos.findClosestByPath(FIND_MY_CREEPS,{filter:s=>{if((s.memory.role==="miner"||s.memory.role==="minerStore")&&s.store[RESOURCE_ENERGY]>0){const c=A(s.pos.x,s.pos.y);return(c==null?void 0:c.length)>1}return!1}});if(a&&!e.pos.isNearTo(a)){e.moveTo(a);return}}const{priority:u="low"}=o!=null?o:{},R=n.Source;if(R.length===0)return;const i=u==="high"?R[0]:R[R.length-1];e.memory.targetSourceId=i.id;const f=e.harvest(i);f===OK?y(10,()=>e.say(l.harvesting)):f===ERR_NOT_IN_RANGE&&e.moveTo(i,{visualizePathStyle:{stroke:"#ffaa00"}});return}},w=(e,o={})=>S.create({baseId:e,body:[WORK,WORK,CARRY,MOVE],role:"harvester",opts:{memory:{task:"harvesting"}},...o}),h={run:G,create:w},M=[STRUCTURE_EXTENSION,STRUCTURE_TOWER,STRUCTURE_WALL,STRUCTURE_RAMPART,STRUCTURE_ROAD,STRUCTURE_CONTAINER],F=(e,o={})=>{const t=e.room.find(FIND_MY_CONSTRUCTION_SITES).sort((r,n)=>{const u=M.indexOf(r.structureType),R=M.indexOf(n.structureType);return u-R});if(t.length===0){h.run(e,o),e.memory.task="harvesting";return}if(e.memory.task==="building"&&e.store[RESOURCE_ENERGY]===0&&(y(10,()=>e.say(l.harvesting)),e.memory.task="harvesting"),e.memory.task==="harvesting"&&e.store.getFreeCapacity()===0&&(y(10,()=>e.say(l.building)),e.memory.task="building"),e.memory.task==="harvesting"&&h.run(e,o),e.memory.task==="building"){const r=t.filter(n=>n.progress<n.progressTotal);if(r.length===0){e.memory.task="harvesting";return}e.build(r[0])===ERR_NOT_IN_RANGE&&e.moveTo(r[0],{visualizePathStyle:{stroke:"#ffffff"}})}},p=(e,o={})=>S.create({baseId:e,body:[WORK,WORK,CARRY,CARRY,MOVE,MOVE],role:"builder",opts:{memory:{task:"building"}},...o}),D={run:F,create:p},x=e=>{e.store.getFreeCapacity()===0&&y(5,()=>e.say(l.full));const o=e.pos.findInRange(FIND_MY_CREEPS,1).filter(r=>r.store.getFreeCapacity()>0).sort((r,n)=>r.memory.role==="miner"&&n.memory.role!=="miner"?1:r.memory.role!=="miner"&&n.memory.role==="miner"?-1:0);if(o.length>0){const r=o[0];e.transfer(r,RESOURCE_ENERGY)===OK&&y(5,()=>e.say(l.transferring))}let t=null;if(e.memory.targetSourceId)t=Game.getObjectById(e.memory.targetSourceId);else{const r=Memory.sources.Source.filter(n=>{const u=Game.getObjectById(n);return u.energy>0&&u.ticksToRegeneration<300}).map(n=>Game.getObjectById(n));t=r.length?r.pop():null}if(t){if(e.memory.targetSourceId=t.id,e.memory.task==="mining"){const r=e.harvest(t);r===OK?y(10,()=>e.say(l.mining)):r===ERR_NOT_ENOUGH_RESOURCES&&y(10,()=>e.say(l.waiting))}e.memory.task==="harvesting"&&(e.moveTo(t,{visualizePathStyle:{stroke:"#ffaa00"},reusePath:5}),e.pos.isNearTo(t)&&(e.memory.task="mining"))}},K=(e,o={})=>S.create({baseId:e,body:[WORK,WORK,WORK,WORK,WORK,CARRY,CARRY,MOVE],role:"miner",opts:{memory:{task:"harvesting"}},...o}),W={run:x,create:K},P=e=>{const o=e.pos.findInRange(FIND_MY_CREEPS,1).filter(t=>t.store.getFreeCapacity()>0&&t.memory.role!=="miner").sort(t=>t.memory.role!=="miner"&&t.memory.role!=="minerStore"?-1:0);for(let t of o)e.transfer(t,RESOURCE_ENERGY)===OK&&y(5,()=>e.say(l.transferring))},$=(e,o={})=>S.create({baseId:e,body:[CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE],role:"minerStore",...o}),B={run:P,create:$},V=e=>{if(e.memory.task==="repairing"&&e.store[RESOURCE_ENERGY]===0){e.say(l.harvesting),e.memory.task="harvesting";return}if(e.memory.task==="harvesting"){e.store.getFreeCapacity()===0?(e.memory.task="repairing",e.say(l.repairing)):h.run(e);return}if(e.memory.task==="repairing"){const o=e.room.find(FIND_STRUCTURES,{filter:r=>r.hits<r.hitsMax||r.structureType===STRUCTURE_TOWER}).sort((r,n)=>r.structureType===STRUCTURE_TOWER&&n.structureType!==STRUCTURE_TOWER?-1:r.structureType!==STRUCTURE_TOWER&&n.structureType===STRUCTURE_TOWER?1:Math.abs(r.hits-n.hits)>1e3?r.hits-n.hits:0);if(!o.length)return;const t=o[0];if(t.structureType===STRUCTURE_TOWER&&t.store.getFreeCapacity(RESOURCE_ENERGY)>0)e.transfer(t,RESOURCE_ENERGY)===OK&&y(5,()=>e.say(l.transferring));else switch(e.repair(t)){case ERR_NOT_IN_RANGE:{e.moveTo(o[0],{visualizePathStyle:{stroke:"#ffffff"}});break}case OK:{y(10,()=>e.say(l.repairing),{time:e.ticksToLive});break}}}},L=(e,o={})=>S.create({baseId:e,body:[WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE],role:"repairer",opts:{memory:{task:"repairing"}},...o}),z={run:V,create:L},j=e=>{if(e.memory.task==="upgrading"&&e.store[RESOURCE_ENERGY]===0){e.say(l.harvesting),e.memory.task="harvesting";return}if(e.memory.task==="harvesting"){e.store.getFreeCapacity()===0?(e.memory.task="upgrading",e.say(l.upgrading)):h.run(e);return}if(e.memory.task==="upgrading"){const o=e.room.controller;if(!o)return;switch(e.upgradeController(o)){case ERR_NOT_IN_RANGE:{e.moveTo(o,{visualizePathStyle:{stroke:"#ffffff"}});break}case OK:{y(10,()=>e.say(l.upgrading),{time:e.ticksToLive});break}}return}},H=(e,o={})=>S.create({baseId:e,body:[WORK,CARRY,CARRY,MOVE,MOVE],role:"upgrader",opts:{memory:{task:"upgrading"}},...o}),q={run:j,create:H},U={builder:D,upgrader:q,miner:W,minerStore:B,repairer:z};class X{constructor(o){O(this,"role");this.role=o}}const N=[STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_CONTAINER,STRUCTURE_STORAGE];class J extends X{constructor(){super("harvester");O(this,"task","harvesting");O(this,"create",t=>{const{baseId:r=g.MainBase,body:n,name:u,memoryRoleOpts:R}=t,i=`${u}-${Game.time}`;return Game.spawns[r].spawnCreep(n,i,{memory:R})})}run(t){if(t.store[RESOURCE_ENERGY]===0&&t.memory.task==="transferring"&&(t.memory.task="harvesting"),t.store.getFreeCapacity()===0&&t.memory.task==="harvesting"&&(t.memory.task="transferring"),t.memory.task==="harvesting"){this.harvestTask(t);return}if(t.memory.task==="transferring"){this.roleTask(t);return}}roleTask(t){const r=t.room.find(FIND_MY_STRUCTURES,{filter:n=>N.includes(n.structureType)&&"store"in n&&n.store.getFreeCapacity(RESOURCE_ENERGY)>0}).sort((n,u)=>{const R=N.indexOf(n.structureType),i=N.indexOf(u.structureType);return R-i});if(r.length>0)switch(t.transfer(r[0],RESOURCE_ENERGY)){case ERR_NOT_IN_RANGE:{t.moveTo(r[0],{visualizePathStyle:{stroke:"#ffffff"}});break}default:y(10,()=>t.say(l.transferring),{time:t.ticksToLive})}}harvestTask(t){const r=t.pos.findClosestByRange(FIND_MY_CREEPS,{filter:n=>n.memory.role==="minerStore"&&n.store[RESOURCE_ENERGY]>0});r&&t.transfer(r,RESOURCE_ENERGY)===OK&&y(10,()=>t.say(l.transferring),{time:t.ticksToLive}),this.getEnergyFromStore(t,["MinerStore","deposit","mineral","source"])}getEnergyFromStore(t,r){var u;let n=null;if(r.length===1){const[R]=r;R&&(n=v(t,R,!0))}else{const R=[];for(const f of r){const a=(u=v(t,f,!1))==null?void 0:u.filter(s=>s!==null);if(a)for(const s of a)s&&R.push(s)}let i=1/0;for(const f of R){const a=t.pos.getRangeTo(f);a<i&&(i=a,n=f)}}if(n){if(!n.pos.isNearTo(t.pos)){t.moveTo(n,{visualizePathStyle:{stroke:"#ffffff"}});return}if(n instanceof Creep)return;if(n instanceof Source||n instanceof Mineral){t.harvest(n),y(10,()=>t.say(l.harvesting),{time:t.ticksToLive});return}if(n instanceof Ruin||n instanceof Tombstone){t.withdraw(n,RESOURCE_ENERGY),y(10,()=>t.say(l.withdrawing),{time:t.ticksToLive});return}if(n instanceof StructureStorage||n instanceof StructureContainer){t.withdraw(n,RESOURCE_ENERGY),y(10,()=>t.say(l.withdrawing),{time:t.ticksToLive});return}if(n instanceof Resource){t.pickup(n),y(10,()=>t.say(l.picking),{time:t.ticksToLive});return}}}}const Q=new J,Y={harvester:Q};class Z{constructor(o){O(this,"tower");this.tower=o}run(){this.tower.store[RESOURCE_ENERGY]!==0&&(this.healFriendlyCreeps(),this.attackHostileCreeps(),this.repairStructures())}attackHostileCreeps(){const o=this.tower.room.find(FIND_HOSTILE_CREEPS,{filter:t=>t.body.some(r=>r.type===ATTACK||r.type===RANGED_ATTACK)});if(o.length>0){const t=o.sort((r,n)=>r.hits-r.hitsMax)[0];this.tower.attack(t)}}healFriendlyCreeps(){const o=this.tower.room.find(FIND_MY_CREEPS,{filter:t=>t.hits<t.hitsMax});if(o.length>0){const t=o.sort((r,n)=>r.hits-n.hits)[0];this.tower.heal(t)}}repairStructures(){const o=this.tower.room.find(FIND_STRUCTURES,{filter:t=>t.hits<1e4&&t.hits<t.hitsMax});if(o.length>0){const t=o.sort((r,n)=>r.hits-n.hits)[0];this.tower.repair(t)}}}const ee=e=>{e.find(FIND_MY_STRUCTURES,{filter:t=>t.structureType===STRUCTURE_TOWER}).forEach(t=>{new Z(t).run()})},te={roleMonitor:{harvester:{count:4,body:[WORK,WORK,CARRY,MOVE]},builder:{count:3,body:[WORK,CARRY,CARRY,MOVE,MOVE]},upgrader:{count:3,body:[WORK,CARRY,CARRY,MOVE,MOVE]},miner:{count:0,body:[WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,MOVE]}}},re={roleMonitor:{harvester:{count:5,body:E([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}])},builder:{count:8,body:E([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}])},upgrader:{count:5,body:E([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}])}}},oe={roleMonitor:{harvester:{count:6,body:E([{body:CARRY,count:7},{body:MOVE,count:4}])},builder:{count:2,body:E([{body:WORK,count:2},{body:CARRY,count:4},{body:MOVE,count:3}])},upgrader:{count:10,body:E([{body:WORK,count:3},{body:CARRY,count:2},{body:MOVE,count:3}])},repairer:{count:1,body:E([{body:WORK,count:2},{body:CARRY,count:4},{body:MOVE,count:3}])}}},ne={roleMonitor:{harvester:{count:8,body:E([{body:CARRY,count:10},{body:MOVE,count:6}])},builder:{count:2,body:E([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])},upgrader:{count:14,body:E([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])},repairer:{count:4,body:E([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])}}},se=[re,oe,ne],ie=e=>{for(let o=e;o>=1;o--){const t=se[o-1];if(t)return t}return te},ae=()=>{Re()},Re=()=>{var r,n,u,R;const e=new Map([["miner",0],["harvester",0],["minerStore",0],["builder",0],["upgrader",0],["repairer",0]]);for(let i in Game.creeps){const f=Game.creeps[i];f.memory.role&&(e.set(f.memory.role,((r=e.get(f.memory.role))!=null?r:0)+1),y(10,()=>S.getVisualStatus(f)))}const o=ie((u=(n=Game.rooms[_.MainRoom].controller)==null?void 0:n.level)!=null?u:0),t=e.entries();for(let[i,f]of t)if(o.roleMonitor[i]&&f<o.roleMonitor[i].count){y(10,()=>{var c;const a=((c=o.roleMonitor[i])==null?void 0:c.body)||[],s={};for(const m of a)s[m]=(s[m]||0)+1;console.log(`${i} 数量不足`,JSON.stringify(s))}),i==="harvester"?(R=Y.harvester)==null||R.create({body:o.roleMonitor[i].body,memoryRoleOpts:{role:i,task:"harvesting"}}):utils.role[i].create(g.MainBase,{body:o.roleMonitor[i].body});break}},ue=()=>{me(),le()},me=()=>{for(let e in Memory.creeps)Game.creeps[e]||(delete Memory.creeps[e],console.log("Clearing non-existing creep memory:",e))},le=()=>{fe()};FIND_DROPPED_RESOURCES,FIND_SOURCES,FIND_TOMBSTONES,FIND_RUINS;const fe=()=>{var n,u;const e=Game.rooms[_.MainRoom];if(!e)return;if(!((n=Memory.sources)!=null&&n.Source)){const R=e.find(FIND_SOURCES);C.set(Memory,"sources.Source",R.map(i=>i.id))}if(!((u=Memory.sources)!=null&&u.Mineral)){const R=e.find(FIND_MINERALS);C.set(Memory,"sources.Mineral",R.map(i=>i.id))}const o=e.find(FIND_DROPPED_RESOURCES);C.set(Memory,"sources.Resource",o.map(R=>R.id));const t=e.find(FIND_RUINS);C.set(Memory,"sources.Ruin",t.map(R=>R.id));const r=e.find(FIND_TOMBSTONES);C.set(Memory,"sources.Tombstone",r.map(R=>R.id))},ye=()=>Ee()?(ce()&&de(),!0):!1,Ee=()=>{const e=[{name:"MinHarvester",role:"harvester"},{name:"MinHarvester2",role:"harvester"},{name:"MinUpgrader",role:"upgrader"},{name:"MinBuilder",role:"builder"},{name:"MinRepairer",role:"repairer"}];for(const o of e)if(!Game.creeps[o.name])return Game.spawns[g.MainBase].spawnCreep(E([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}]),o.name,{memory:{role:o.role,task:"harvesting"}}),y(10,()=>console.log(`MinCreepGroup中缺少: ${o.name}, 等待孵化...`)),!1;return!0},ce=()=>{const e=[{name:"FixedMiner1",pos:{x:9,y:44},targetId:"5bbcaffd9099fc012e63b77c"},{name:"FixedMiner2",pos:{x:4,y:40},targetId:"5bbcaffd9099fc012e63b77b"}];let o=!0;for(const t of e){const r=Game.creeps[t.name];if(!r){Game.spawns[g.MainBase].spawnCreep(E([{body:WORK,count:6},{body:CARRY,count:3},{body:MOVE,count:1}]),t.name,{memory:{role:"miner",task:"harvesting",targetId:t.targetId}}),o=!1;continue}r.memory.task!=="harvesting"&&r.moveTo(t.pos.x,t.pos.y)}return o},de=()=>{const e=[{name:"MinerStore-2",pos:{x:5,y:39}},{name:"MinerStore-3",pos:{x:10,y:43}}];for(const o of e){const t=Game.creeps[o.name];t?t.moveTo(o.pos.x,o.pos.y):Game.spawns[g.MainBase].spawnCreep(E([{body:CARRY,count:15},{body:MOVE,count:1}]),o.name,{memory:{role:"minerStore"}})}return!0},ge=()=>{ue(),ye()&&y(10,ae)},Se=()=>{var e,o,t,r;for(let n in Game.rooms){const u=Game.rooms[n];if((e=u.controller)!=null&&e.my){ge();for(let R in Game.creeps){let i=Game.creeps[R];if(i.memory.role=="harvester"&&((o=Y.harvester)==null||o.run(i)),i.memory.role=="builder"){const f=Object.values(Game.creeps).filter(a=>a.memory.role==="builder").findIndex((a,s)=>a.name===i.name&&s<3)!==-1;(t=U.builder)==null||t.run(i,{priority:f?"high":"low"})}i.memory.role&&((r=U[i.memory.role])==null||r.run(i))}ee(u)}}};module.exports={loop:Se};global.utils={role:U};
