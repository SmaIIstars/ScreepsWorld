"use strict";var $=Object.defineProperty;var L=(e,t,r)=>t in e?$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var C=(e,t,r)=>L(e,typeof t!="symbol"?t+"":t,r);const h=require("lodash"),l={mining:"⛏️",harvesting:"⛏️",picking:"⛏️",withdrawing:"📥",transferring:"🔄",receiving:"📥",moving:"🚶",building:"🚧",upgrading:"⚡",repairing:"🔧"},y=(e,t,r={})=>{const{time:o=Game.time}=r;o%e===0&&t()};var S=(e=>(e.MainBase="Spawn1",e))(S||{}),p=(e=>(e.MainRoom="E49S54",e))(p||{});Object.values(S);const U={getVisualStatus:e=>{var o;const t=e.fatigue,r=`${(o=e.memory.role)==null?void 0:o.slice(0,3)} ${t>0?t:""}`;return e.room.visual.text(r,e.pos.x,e.pos.y-1,{font:.5,color:"#00ff00",stroke:"#000000",strokeWidth:.1})},create:e=>{var n,i;const{baseId:t=S.MainBase,body:r,name:o,role:s,opts:u}=e,a=o!=null?o:`${s}-${Game.time}`;return(i=(n=Game.spawns)==null?void 0:n[t])==null?void 0:i.spawnCreep(r,a,h.merge({memory:{role:s}},u))}},f=e=>e.reduce((t,{body:r,count:o})=>t.concat(Array(o).fill(r)),[]);function k(e,t,r=1){var n;const o=Game.rooms[S.MainBase];if(!o)return[];const s=new Set,u=[],a=[{x:e,y:t}];for(;a.length>0;){const i=a.shift(),m=`${i.x}-${i.y}`;if(s.has(m))continue;s.add(m);const R=o.lookAtArea(i.y-r,i.x-r,i.y+r,i.x+r,!0),E={};for(const c of R){const g=`${c.x}-${c.y}`;E[g]||(E[g]=[]),E[g].push(c)}for(const[c,g]of Object.entries(E)){if(g.some(d=>d.terrain==="wall"||d.type==="source"))continue;const T=g.find(d=>d.type==="creep");if(T&&T.creep){const d=Game.creeps[T.creep.name];if(d&&["miner","minerStore"].includes((n=d.memory.role)!=null?n:"")){const[P,V]=c.split("-").map(Number);s.has(c)||a.push({x:P,y:V});continue}else continue}if(g.some(d=>d.type==="structure"))continue;const[w,F]=c.split("-").map(Number);u.some(d=>d.x===w&&d.y===F)||u.push({x:w,y:F})}}return u}function W(e,t,r){return t==="miner"?r?e.pos.findClosestByRange(FIND_MY_CREEPS,{filter:o=>o.memory.role==="miner"&&o.store[RESOURCE_ENERGY]>0}):e.room.find(FIND_MY_CREEPS,{filter:o=>o.memory.role==="miner"&&o.store[RESOURCE_ENERGY]>0}):t==="container"?r?e.pos.findClosestByRange(FIND_MY_STRUCTURES,{filter:o=>o.structureType==="container"&&o.store.getFreeCapacity(RESOURCE_ENERGY)>0}):e.room.find(FIND_MY_STRUCTURES,{filter:o=>o.structureType==="container"&&o.store.getFreeCapacity(RESOURCE_ENERGY)>0}):t==="storage"?r?e.pos.findClosestByRange(FIND_MY_STRUCTURES,{filter:o=>o.structureType==="storage"&&o.store.getFreeCapacity(RESOURCE_ENERGY)>0}):e.room.find(FIND_MY_STRUCTURES,{filter:o=>o.structureType==="storage"&&o.store.getFreeCapacity(RESOURCE_ENERGY)>0}):t==="source"?r?e.pos.findClosestByRange(FIND_SOURCES,{filter:o=>o.energy>0&&k(o.pos.x,o.pos.y).length>1}):e.room.find(FIND_SOURCES,{filter:o=>o.energy>0&&k(o.pos.x,o.pos.y).length>1}):t==="mineral"?r?e.pos.findClosestByRange(FIND_MINERALS,{filter:o=>o.mineralAmount>0}):e.room.find(FIND_MINERALS,{filter:o=>o.mineralAmount>0}):t==="ruin"?r?e.pos.findClosestByRange(FIND_RUINS,{filter:o=>o.store[RESOURCE_ENERGY]>0}):e.room.find(FIND_RUINS,{filter:o=>o.store[RESOURCE_ENERGY]>0}):t==="tombstone"?r?e.pos.findClosestByRange(FIND_TOMBSTONES,{filter:o=>o.store[RESOURCE_ENERGY]>0}):e.room.find(FIND_TOMBSTONES,{filter:o=>o.store[RESOURCE_ENERGY]>0}):t==="resource"?r?e.pos.findClosestByRange(FIND_DROPPED_RESOURCES,{filter:o=>o.amount>0}):e.room.find(FIND_DROPPED_RESOURCES,{filter:o=>o.amount>0}):null}const v=[STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_CONTAINER,STRUCTURE_STORAGE],z=(e,t)=>{var r;if(e.memory.task==="transferring"){if(e.store[RESOURCE_ENERGY]===0){e.memory.task="harvesting";return}const o=e.room.find(FIND_STRUCTURES,{filter:s=>v.includes(s.structureType)&&"store"in s&&s.store.getFreeCapacity(RESOURCE_ENERGY)>0}).sort((s,u)=>{const a=v.indexOf(s.structureType),n=v.indexOf(u.structureType);return a-n});o.length>0&&e.transfer(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0],{visualizePathStyle:{stroke:"#ffffff"}});return}if(e.store.getFreeCapacity()===0){e.memory.role==="harvester"&&(e.memory.task="transferring");return}if(e.store[RESOURCE_ENERGY]===0&&e.memory.task!=="harvesting"){e.memory.task="harvesting";return}if(e.store.getFreeCapacity()>0&&e.memory.task==="harvesting"){if(e.memory.role!=="harvester"){const m=e.room.find(FIND_STRUCTURES,{filter:R=>R.structureType===STRUCTURE_CONTAINER&&R.store[RESOURCE_ENERGY]>e.store.getFreeCapacity()});if(m.length>0)if(e.pos.isNearTo(m[0])){e.withdraw(m[0],RESOURCE_ENERGY)===OK&&e.say(l.receiving);return}else{e.moveTo(m[0],{visualizePathStyle:{stroke:"#ffaa00"}});return}}const s=Object.values(Memory.sources.Source).map(m=>Game.getObjectById(m)).reduce((m,R)=>{var E,c,g,T;return R instanceof Source&&R.energy>0?m.Source=[...(E=m.Source)!=null?E:[],R]:R instanceof Resource&&R.amount>0?m.Resource=[...(c=m.Resource)!=null?c:[],R]:R instanceof Tombstone&&R.store[RESOURCE_ENERGY]>0?m.Tombstone=[...(g=m.Tombstone)!=null?g:[],R]:R instanceof Ruin&&R.store[RESOURCE_ENERGY]>0&&(m.Ruin=[...(T=m.Ruin)!=null?T:[],R]),m},{Source:[],Resource:[],Tombstone:[],Ruin:[]});if(s.Resource.length>0){const m=s.Resource[0],R=e.pickup(m);R===OK?e.say(l.harvesting):R===ERR_NOT_IN_RANGE&&e.moveTo(m,{visualizePathStyle:{stroke:"#ffaa00"}});return}if(e.memory.role!=="harvester"&&(s.Tombstone.length>0||s.Ruin.length>0)){const m=(r=s.Tombstone[0])!=null?r:s.Ruin[0],R=e.withdraw(m,RESOURCE_ENERGY);R===OK?e.say(l.harvesting):R===ERR_NOT_IN_RANGE&&e.moveTo(m,{visualizePathStyle:{stroke:"#ffaa00"}});return}if(e.memory.role!=="harvester"||e.memory.role==="harvester"&&(t==null?void 0:t.priority)==="high"){const m=e.pos.findClosestByPath(FIND_MY_CREEPS,{filter:R=>{if((R.memory.role==="miner"||R.memory.role==="minerStore")&&R.store[RESOURCE_ENERGY]>0){const E=k(R.pos.x,R.pos.y);return(E==null?void 0:E.length)>1}return!1}});if(m&&!e.pos.isNearTo(m)){e.moveTo(m);return}}const{priority:u="low"}=t!=null?t:{},a=s.Source;if(a.length===0)return;const n=u==="high"?a[0]:a[a.length-1];e.memory.targetSourceId=n.id;const i=e.harvest(n);i===OK?y(10,()=>e.say(l.harvesting)):i===ERR_NOT_IN_RANGE&&e.moveTo(n,{visualizePathStyle:{stroke:"#ffaa00"}});return}},j=(e,t={})=>U.create({baseId:e,body:[WORK,WORK,CARRY,MOVE],role:"harvester",opts:{memory:{task:"harvesting"}},...t}),K={run:z,create:j},H=e=>{if(e.memory.task==="repairing"&&e.store[RESOURCE_ENERGY]===0){e.say(l.harvesting),e.memory.task="harvesting";return}if(e.memory.task==="harvesting"){e.store.getFreeCapacity()===0?(e.memory.task="repairing",e.say(l.repairing)):K.run(e);return}if(e.memory.task==="repairing"){const t=e.room.find(FIND_STRUCTURES,{filter:o=>o.hits<o.hitsMax||o.structureType===STRUCTURE_TOWER}).sort((o,s)=>o.structureType===STRUCTURE_TOWER&&s.structureType!==STRUCTURE_TOWER?-1:o.structureType!==STRUCTURE_TOWER&&s.structureType===STRUCTURE_TOWER?1:Math.abs(o.hits-s.hits)>1e3?o.hits-s.hits:0);if(!t.length)return;const r=t[0];if(!r.pos.isNearTo(e)){e.moveTo(r,{visualizePathStyle:{stroke:"#ffffff"}});return}if(r.structureType===STRUCTURE_TOWER&&r.store.getFreeCapacity(RESOURCE_ENERGY)>0)e.transfer(r,RESOURCE_ENERGY)===OK&&y(5,()=>e.say(l.transferring));else switch(e.repair(r)){case ERR_NOT_IN_RANGE:{e.moveTo(t[0],{visualizePathStyle:{stroke:"#ffffff"}});break}case OK:{y(10,()=>e.say(l.repairing),{time:e.ticksToLive});break}}}},X=(e,t={})=>U.create({baseId:e,body:[WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE],role:"repairer",opts:{memory:{task:"repairing"}},...t}),q={run:H,create:X},J=e=>{if(e.memory.task==="upgrading"&&e.store[RESOURCE_ENERGY]===0&&(e.say(l.harvesting),e.memory.task="harvesting"),e.memory.task==="harvesting"&&e.store.getFreeCapacity()===0&&(e.memory.task="upgrading",e.say(l.upgrading)),e.memory.task==="harvesting"){K.run(e);return}if(e.memory.task==="upgrading"){const t=e.room.controller;if(!t)return;switch(e.upgradeController(t)){case ERR_NOT_IN_RANGE:{e.moveTo(t,{visualizePathStyle:{stroke:"#ffffff"}});break}case OK:{y(10,()=>e.say(l.upgrading),{time:e.ticksToLive});break}}return}},Q=(e,t={})=>U.create({baseId:e,body:[WORK,CARRY,CARRY,MOVE,MOVE],role:"upgrader",opts:{memory:{task:"upgrading"}},...t}),Z={run:J,create:Q},B={upgrader:Z,repairer:q};class A{constructor(t){C(this,"role");this.role=t}getEnergyFromStore(t,r){var s,u;let o=null;if(r.length===1){const[a]=r;a&&(o=W(t,a,!0))}else{const a=[];for(const i of r){const m=(u=(s=W(t,i,!1))==null?void 0:s.filter(R=>R!==null))!=null?u:[];for(const R of m)R&&a.push(R)}let n=[];if(n=a.filter(i=>i instanceof Resource&&i.resourceType===RESOURCE_ENERGY||i instanceof Ruin||i instanceof Tombstone),n.length>0&&(o=t.pos.findClosestByRange(n)),o||(n=a.filter(i=>i instanceof StructureContainer&&i.store[RESOURCE_ENERGY]>0),n.length>0&&(o=t.pos.findClosestByRange(n))),o||(n=a.filter(i=>i instanceof StructureStorage&&i.store[RESOURCE_ENERGY]>0),n.length>0&&(o=t.pos.findClosestByRange(n))),!o){const i=a.filter(R=>R instanceof Creep&&R.memory&&R.memory.role==="miner"&&R.store[RESOURCE_ENERGY]>0),m=i.filter(R=>R.store.getFreeCapacity(RESOURCE_ENERGY)===0);m.length>0?o=t.pos.findClosestByRange(m):i.length>0&&(o=t.pos.findClosestByRange(i))}o||(n=a.filter(i=>i instanceof Source),n.length>0&&(o=t.pos.findClosestByRange(n))),o||(n=a.filter(i=>i instanceof Mineral||i instanceof Deposit),n.length>0&&(o=t.pos.findClosestByRange(n)))}if(o){if(!o.pos.isNearTo(t.pos)){t.moveTo(o,{visualizePathStyle:{stroke:"#ffffff"}});return}if(o instanceof Creep&&o.memory.role==="miner")return;if(o instanceof Source||o instanceof Mineral){t.harvest(o),y(10,()=>t.say(l.harvesting),{time:t.ticksToLive});return}if(o instanceof Ruin||o instanceof Tombstone){t.withdraw(o,RESOURCE_ENERGY),y(10,()=>t.say(l.withdrawing),{time:t.ticksToLive});return}if(o instanceof StructureStorage||o instanceof StructureContainer){t.withdraw(o,RESOURCE_ENERGY),y(10,()=>t.say(l.withdrawing),{time:t.ticksToLive});return}if(o instanceof Resource){t.pickup(o),y(10,()=>t.say(l.picking),{time:t.ticksToLive});return}}}}const D=[STRUCTURE_EXTENSION,STRUCTURE_TOWER,STRUCTURE_WALL,STRUCTURE_RAMPART,STRUCTURE_ROAD,STRUCTURE_CONTAINER],b=class b extends A{constructor(){super(b.role)}create(t){const{baseId:r=S.MainBase,body:o,name:s,memoryRoleOpts:u={role:"builder",task:"harvesting"}}=t,a=s!=null?s:`${this.role}-${Game.time}`;return Game.spawns[r].spawnCreep(o,a,{memory:u})}run(t){if(t.store[RESOURCE_ENERGY]===0&&t.memory.task!=="harvesting"&&(t.memory.task="harvesting"),t.store.getFreeCapacity()===0&&t.memory.task==="harvesting"&&(t.memory.task="building"),t.memory.task==="harvesting"){this.getEnergyFromStore(t,["resource","ruin","tombstone","storage","miner","source"]);return}this.roleTask(t)}roleTask(t){const r=t.room.find(FIND_MY_CONSTRUCTION_SITES).sort((o,s)=>{const u=D.indexOf(o.structureType),a=D.indexOf(s.structureType);return u-a});if(r.length>0)switch(t.memory.task==="repairing"&&(t.memory.task="building"),t.build(r[0])){case ERR_NOT_IN_RANGE:{t.moveTo(r[0],{visualizePathStyle:{stroke:"#ffffff"}});break}default:{y(10,()=>t.say(l.building),{time:t.ticksToLive});break}}else t.memory.task="repairing",this.roleTask2(t)}roleTask2(t){}};C(b,"role","builder");let Y=b;const tt=new Y,M=[STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_STORAGE,STRUCTURE_CONTAINER],N=class N extends A{constructor(){super(N.role);C(this,"create",r=>{const{baseId:o=S.MainBase,body:s,name:u,memoryRoleOpts:a={role:"harvester",task:"harvesting"}}=r,n=u!=null?u:`${this.role}-${Game.time}`;return Game.spawns[o].spawnCreep(s,n,{memory:a})})}run(r){if(r.store[RESOURCE_ENERGY]===0&&r.memory.task==="transferring"&&(r.memory.task="harvesting"),r.store.getFreeCapacity()===0&&r.memory.task==="harvesting"&&(r.memory.task="transferring"),r.memory.task==="harvesting"){this.harvestTask(r);return}this.roleTask(r)}roleTask(r){const o=r.room.find(FIND_MY_STRUCTURES,{filter:s=>M.includes(s.structureType)&&"store"in s&&s.store.getFreeCapacity(RESOURCE_ENERGY)>0}).sort((s,u)=>{if(s.structureType===u.structureType)return s.pos.getRangeTo(r.pos)-u.pos.getRangeTo(r.pos);const a=M.indexOf(s.structureType),n=M.indexOf(u.structureType);return a-n});if(o.length>0)switch(r.transfer(o[0],RESOURCE_ENERGY)){case ERR_NOT_IN_RANGE:{r.moveTo(o[0],{visualizePathStyle:{stroke:"#ffffff"}});break}default:y(10,()=>r.say(l.transferring),{time:r.ticksToLive})}}harvestTask(r){this.getEnergyFromStore(r,["resource","ruin","tombstone","container","miner","source"])}};C(N,"role","harvester");let I=N;const et=new I,_=class _ extends A{constructor(){super(_.role)}create(t){const{baseId:r=S.MainBase,body:o,name:s,memoryRoleOpts:u={role:this.role,task:"moving"}}=t,a=s!=null?s:`${this.role}-${Game.time}`;return Game.spawns[r].spawnCreep(o,a,{memory:u})}run(t){t.memory.task==="moving"?this.moveTask(t):this.roleTask(t)}moveTask(t){var o;let r=null;t.memory.targetId?r=Game.getObjectById(t.memory.targetId):r=(o=Memory.sources.Source.map(u=>Game.getObjectById(u)).filter(u=>u!==null).find(u=>u.pos.findInRange(FIND_MY_CREEPS,1,{filter:n=>n.memory.role==="miner"&&n.name!==t.name}).length===0))!=null?o:null,r&&(t.pos.isNearTo(r)?(t.memory.task="mining",t.memory.targetId=r.id):(t.moveTo(r,{visualizePathStyle:{stroke:"#ffffff"}}),y(10,()=>t.say(l.moving))))}roleTask(t){const r=t.pos.findInRange(FIND_MY_CREEPS,1,{filter:o=>o.memory.role!=="miner"&&o.store.getFreeCapacity(RESOURCE_ENERGY)>0});for(const o of r)t.store[RESOURCE_ENERGY]>0&&o.store.getFreeCapacity(RESOURCE_ENERGY)>0&&(t.transfer(o,RESOURCE_ENERGY),y(10,()=>t.say(l.transferring)));if(t.memory.targetId){const o=Game.getObjectById(t.memory.targetId);o&&(t.harvest(o),y(10,()=>t.say(l.mining)));return}t.memory.task="moving"}};C(_,"role","miner");let G=_;const ot=new G,O={harvester:et,builder:tt,miner:ot};class rt{constructor(t){C(this,"tower");this.tower=t}run(){this.tower.store[RESOURCE_ENERGY]!==0&&(this.healFriendlyCreeps(),this.attackHostileCreeps(),this.repairStructures())}attackHostileCreeps(){const t=this.tower.room.find(FIND_HOSTILE_CREEPS,{filter:r=>r.body.some(o=>o.type===ATTACK||o.type===RANGED_ATTACK)});if(t.length>0){const r=t.sort((o,s)=>o.hits-o.hitsMax)[0];this.tower.attack(r)}}healFriendlyCreeps(){const t=this.tower.room.find(FIND_MY_CREEPS,{filter:r=>r.hits<r.hitsMax});if(t.length>0){const r=t.sort((o,s)=>o.hits-s.hits)[0];this.tower.heal(r)}}repairStructures(){const t=this.tower.room.find(FIND_STRUCTURES,{filter:r=>r.hits<1e5&&r.hits<r.hitsMax});if(t.length>0){const r=t.sort((o,s)=>o.hits-s.hits)[0];this.tower.repair(r)}}}const st=e=>{e.find(FIND_MY_STRUCTURES,{filter:r=>r.structureType===STRUCTURE_TOWER}).forEach(r=>{new rt(r).run()})},nt=()=>{it(),Rt(),at()},it=()=>{for(let e in Memory.creeps)Game.creeps[e]||(delete Memory.creeps[e],console.log("Clearing non-existing creep memory:",e))},at=()=>{var t;const e={harvester:0,builder:0,upgrader:0,miner:0,minerStore:0,repairer:0};for(const r of Object.values(Game.creeps))r.memory.role&&(e[r.memory.role]=((t=e[r.memory.role])!=null?t:0)+1);Memory.creepsCount=e},Rt=()=>{ut()},ut=()=>{var s,u;const e=Game.rooms[p.MainRoom];if(!e)return;if(!((s=Memory.sources)!=null&&s.Source)){const a=e.find(FIND_SOURCES);h.set(Memory,"sources.Source",a.map(n=>n.id))}if(!((u=Memory.sources)!=null&&u.Mineral)){const a=e.find(FIND_MINERALS);h.set(Memory,"sources.Mineral",a.map(n=>n.id))}const t=e.find(FIND_DROPPED_RESOURCES);h.set(Memory,"sources.Resource",t.map(a=>a.id));const r=e.find(FIND_RUINS);h.set(Memory,"sources.Ruin",r.map(a=>a.id));const o=e.find(FIND_TOMBSTONES);h.set(Memory,"sources.Tombstone",o.map(a=>a.id))},mt=()=>{y(10,lt)},lt=()=>{const e=Object.values(Game.spawns);for(const t of e)t.spawning?t.room.visual.text(`Spawning:${t.spawning.name}`,{...t.pos,y:t.pos.y-1},{font:.5,color:"#00ff00",stroke:"#000000",strokeWidth:.1}):t.room.visual.text(`${t.store[RESOURCE_ENERGY]}`,{...t.pos,y:t.pos.y+1},{font:.5,color:"#00ff00",stroke:"#000000",strokeWidth:.1})},ft={roleMonitor:{harvester:{count:4,body:[WORK,WORK,CARRY,MOVE]},builder:{count:3,body:[WORK,CARRY,CARRY,MOVE,MOVE]},upgrader:{count:3,body:[WORK,CARRY,CARRY,MOVE,MOVE]},miner:{count:0,body:[WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,MOVE]}}},yt={roleMonitor:{harvester:{count:5,body:f([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}])},builder:{count:8,body:f([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}])},upgrader:{count:5,body:f([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}])}}},Et={roleMonitor:{harvester:{count:6,body:f([{body:CARRY,count:7},{body:MOVE,count:4}])},builder:{count:2,body:f([{body:WORK,count:2},{body:CARRY,count:4},{body:MOVE,count:3}])},upgrader:{count:10,body:f([{body:WORK,count:3},{body:CARRY,count:2},{body:MOVE,count:3}])},repairer:{count:1,body:f([{body:WORK,count:2},{body:CARRY,count:4},{body:MOVE,count:3}])}}},ct={roleMonitor:{harvester:{count:4,body:f([{body:CARRY,count:11},{body:MOVE,count:5}])},builder:{count:3,body:f([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])},upgrader:{count:6,body:f([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])},repairer:{count:5,body:f([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])}}},dt={roleMonitor:{harvester:{count:5,body:f([{body:CARRY,count:13},{body:MOVE,count:13}])},builder:{count:2,body:f([{body:WORK,count:5},{body:CARRY,count:8},{body:MOVE,count:8}])},upgrader:{count:4,body:f([{body:WORK,count:5},{body:CARRY,count:8},{body:MOVE,count:8}])},repairer:{count:4,body:f([{body:WORK,count:5},{body:CARRY,count:8},{body:MOVE,count:8}])}}},gt=[yt,Et,ct,dt],St=e=>{for(let t=e;t>=1;t--){const r=gt[t-1];if(r)return r}return ft},Ct=()=>{Tt()},Tt=()=>{var o,s,u,a;const e=new Map([["miner",0],["harvester",0],["minerStore",0],["builder",0],["upgrader",0],["repairer",0]]);for(let n in Game.creeps){const i=Game.creeps[n];i.memory.role&&(e.set(i.memory.role,((o=e.get(i.memory.role))!=null?o:0)+1),y(10,()=>U.getVisualStatus(i)))}const t=St((u=(s=Game.rooms[p.MainRoom].controller)==null?void 0:s.level)!=null?u:0),r=e.entries();for(let[n,i]of r)if(t.roleMonitor[n]&&i<t.roleMonitor[n].count){y(10,()=>{var E;const m=((E=t.roleMonitor[n])==null?void 0:E.body)||[],R={};for(const c of m)R[c]=(R[c]||0)+1;console.log(`${n} 数量不足`,JSON.stringify(R))}),["harvester","builder"].includes(n)?(a=O[n])==null||a.create({body:t.roleMonitor[n].body,memoryRoleOpts:{role:n,task:"harvesting"}}):utils.role[n].create(S.MainBase,{body:t.roleMonitor[n].body});break}},x=["MinMiner","MinMiner2"],ht=()=>{Ot()&&Ct()},Ot=()=>{const e=[...x.map(t=>({name:t,role:"miner"})),{name:"MinHarvester",role:"harvester"},{name:"MinHarvester2",role:"harvester"},{name:"MinUpgrader",role:"upgrader"},{name:"MinBuilder",role:"builder"}];for(const t of e){if(x.includes(t.name)&&Memory.creepsCount.miner>=2||t.name.startsWith("MinHarvester")&&Memory.creepsCount.harvester>=2||t.name==="MinUpgrader"&&Memory.creepsCount.upgrader>=1)continue;if(!Game.creeps[t.name]){let o=[];switch(t.role){case"miner":{o=f([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}]);break}default:{o=f([{body:WORK,count:1},{body:CARRY,count:2},{body:MOVE,count:2}]);break}}return Game.spawns[S.MainBase].spawnCreep(o,t.name,{memory:{role:t.role,task:t.role==="miner"?"moving":"harvesting"}}),!1}}return!0},bt=()=>{mt(),nt(),ht()},Nt=()=>{var e,t,r,o,s;for(let u in Game.rooms){const a=Game.rooms[u];if((e=a.controller)!=null&&e.my){bt();for(let n in Game.creeps){let i=Game.creeps[n];i.memory.role=="harvester"&&((t=O.harvester)==null||t.run(i)),i.memory.role=="builder"&&((r=O.builder)==null||r.run(i)),i.memory.role=="miner"&&((o=O.miner)==null||o.run(i)),i.memory.role&&((s=B[i.memory.role])==null||s.run(i))}st(a)}}};module.exports={loop:Nt};global.utils={role:B};
