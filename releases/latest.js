"use strict";var L=Object.defineProperty;var z=(t,e,r)=>e in t?L(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var C=(t,e,r)=>z(t,typeof e!="symbol"?e+"":e,r);const h=require("lodash"),l={mining:"⛏️",harvesting:"⛏️",picking:"⛏️",withdrawing:"📥",transferring:"🔄",receiving:"📥",moving:"🚶",building:"🚧",upgrading:"⚡",repairing:"🔧"},f=(t,e,r={})=>{const{time:o=Game.time}=r;o%t===0&&e()};var S=(t=>(t.MainBase="Spawn1",t))(S||{}),A=(t=>(t.MainRoom="E49S54",t))(A||{});Object.values(S);const M={getVisualStatus:t=>{var o;const e=t.fatigue,r=`${(o=t.memory.role)==null?void 0:o.slice(0,3)} ${e>0?e:""}`;return t.room.visual.text(r,t.pos.x,t.pos.y-1,{font:.5,color:"#00ff00",stroke:"#000000",strokeWidth:.1})},create:t=>{var s,i;const{baseId:e=S.MainBase,body:r,name:o,role:n,opts:R}=t,a=o!=null?o:`${n}-${Game.time}`;return(i=(s=Game.spawns)==null?void 0:s[e])==null?void 0:i.spawnCreep(r,a,h.merge({memory:{role:n}},R))}},y=t=>t.reduce((e,{body:r,count:o})=>e.concat(Array(o).fill(r)),[]);function p(t,e,r=1){var s;const o=Game.rooms[S.MainBase];if(!o)return[];const n=new Set,R=[],a=[{x:t,y:e}];for(;a.length>0;){const i=a.shift(),m=`${i.x}-${i.y}`;if(n.has(m))continue;n.add(m);const u=o.lookAtArea(i.y-r,i.x-r,i.y+r,i.x+r,!0),E={};for(const c of u){const g=`${c.x}-${c.y}`;E[g]||(E[g]=[]),E[g].push(c)}for(const[c,g]of Object.entries(E)){if(g.some(d=>d.terrain==="wall"||d.type==="source"))continue;const O=g.find(d=>d.type==="creep");if(O&&O.creep){const d=Game.creeps[O.creep.name];if(d&&["miner","minerStore"].includes((s=d.memory.role)!=null?s:"")){const[V,$]=c.split("-").map(Number);n.has(c)||a.push({x:V,y:$});continue}else continue}if(g.some(d=>d.type==="structure"))continue;const[F,W]=c.split("-").map(Number);R.some(d=>d.x===F&&d.y===W)||R.push({x:F,y:W})}}return R}function x(t,e,r){return e==="miner"?r?t.pos.findClosestByRange(FIND_MY_CREEPS,{filter:o=>o.memory.role==="miner"&&o.store[RESOURCE_ENERGY]>0}):t.room.find(FIND_MY_CREEPS,{filter:o=>o.memory.role==="miner"&&o.store[RESOURCE_ENERGY]>0}):["container","storage"].includes(e)?r?t.pos.findClosestByRange(FIND_MY_STRUCTURES,{filter:o=>["storage","container"].includes(o.structureType)&&o.store.getFreeCapacity(RESOURCE_ENERGY)>0}):t.room.find(FIND_MY_STRUCTURES,{filter:o=>["storage","container"].includes(o.structureType)&&o.store.getFreeCapacity(RESOURCE_ENERGY)>0}):e==="source"?r?t.pos.findClosestByRange(FIND_SOURCES,{filter:o=>o.energy>0&&p(o.pos.x,o.pos.y).length>1}):t.room.find(FIND_SOURCES,{filter:o=>o.energy>0&&p(o.pos.x,o.pos.y).length>1}):e==="mineral"?r?t.pos.findClosestByRange(FIND_MINERALS,{filter:o=>o.mineralAmount>0}):t.room.find(FIND_MINERALS,{filter:o=>o.mineralAmount>0}):e==="ruin"?r?t.pos.findClosestByRange(FIND_RUINS,{filter:o=>o.store[RESOURCE_ENERGY]>0}):t.room.find(FIND_RUINS,{filter:o=>o.store[RESOURCE_ENERGY]>0}):e==="tombstone"?r?t.pos.findClosestByRange(FIND_TOMBSTONES,{filter:o=>o.store[RESOURCE_ENERGY]>0}):t.room.find(FIND_TOMBSTONES,{filter:o=>o.store[RESOURCE_ENERGY]>0}):e==="resource"?r?t.pos.findClosestByRange(FIND_DROPPED_RESOURCES,{filter:o=>o.amount>0}):t.room.find(FIND_DROPPED_RESOURCES,{filter:o=>o.amount>0}):null}const U=[STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_CONTAINER,STRUCTURE_STORAGE],j=(t,e)=>{var r;if(t.memory.task==="transferring"){if(t.store[RESOURCE_ENERGY]===0){t.memory.task="harvesting";return}const o=t.room.find(FIND_STRUCTURES,{filter:n=>U.includes(n.structureType)&&"store"in n&&n.store.getFreeCapacity(RESOURCE_ENERGY)>0}).sort((n,R)=>{const a=U.indexOf(n.structureType),s=U.indexOf(R.structureType);return a-s});o.length>0&&t.transfer(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&t.moveTo(o[0],{visualizePathStyle:{stroke:"#ffffff"}});return}if(t.store.getFreeCapacity()===0){t.memory.role==="harvester"&&(t.memory.task="transferring");return}if(t.store[RESOURCE_ENERGY]===0&&t.memory.task!=="harvesting"){t.memory.task="harvesting";return}if(t.store.getFreeCapacity()>0&&t.memory.task==="harvesting"){if(t.memory.role!=="harvester"){const m=t.room.find(FIND_STRUCTURES,{filter:u=>u.structureType===STRUCTURE_CONTAINER&&u.store[RESOURCE_ENERGY]>t.store.getFreeCapacity()});if(m.length>0)if(t.pos.isNearTo(m[0])){t.withdraw(m[0],RESOURCE_ENERGY)===OK&&t.say(l.receiving);return}else{t.moveTo(m[0],{visualizePathStyle:{stroke:"#ffaa00"}});return}}const n=Object.values(Memory.sources.Source).map(m=>Game.getObjectById(m)).reduce((m,u)=>{var E,c,g,O;return u instanceof Source&&u.energy>0?m.Source=[...(E=m.Source)!=null?E:[],u]:u instanceof Resource&&u.amount>0?m.Resource=[...(c=m.Resource)!=null?c:[],u]:u instanceof Tombstone&&u.store[RESOURCE_ENERGY]>0?m.Tombstone=[...(g=m.Tombstone)!=null?g:[],u]:u instanceof Ruin&&u.store[RESOURCE_ENERGY]>0&&(m.Ruin=[...(O=m.Ruin)!=null?O:[],u]),m},{Source:[],Resource:[],Tombstone:[],Ruin:[]});if(n.Resource.length>0){const m=n.Resource[0],u=t.pickup(m);u===OK?t.say(l.harvesting):u===ERR_NOT_IN_RANGE&&t.moveTo(m,{visualizePathStyle:{stroke:"#ffaa00"}});return}if(t.memory.role!=="harvester"&&(n.Tombstone.length>0||n.Ruin.length>0)){const m=(r=n.Tombstone[0])!=null?r:n.Ruin[0],u=t.withdraw(m,RESOURCE_ENERGY);u===OK?t.say(l.harvesting):u===ERR_NOT_IN_RANGE&&t.moveTo(m,{visualizePathStyle:{stroke:"#ffaa00"}});return}if(t.memory.role!=="harvester"||t.memory.role==="harvester"&&(e==null?void 0:e.priority)==="high"){const m=t.pos.findClosestByPath(FIND_MY_CREEPS,{filter:u=>{if((u.memory.role==="miner"||u.memory.role==="minerStore")&&u.store[RESOURCE_ENERGY]>0){const E=p(u.pos.x,u.pos.y);return(E==null?void 0:E.length)>1}return!1}});if(m&&!t.pos.isNearTo(m)){t.moveTo(m);return}}const{priority:R="low"}=e!=null?e:{},a=n.Source;if(a.length===0)return;const s=R==="high"?a[0]:a[a.length-1];t.memory.targetSourceId=s.id;const i=t.harvest(s);i===OK?f(10,()=>t.say(l.harvesting)):i===ERR_NOT_IN_RANGE&&t.moveTo(s,{visualizePathStyle:{stroke:"#ffaa00"}});return}},H=(t,e={})=>M.create({baseId:t,body:[WORK,WORK,CARRY,MOVE],role:"harvester",opts:{memory:{task:"harvesting"}},...e}),B={run:j,create:H},X=t=>{if(t.memory.task==="repairing"&&t.store[RESOURCE_ENERGY]===0){t.say(l.harvesting),t.memory.task="harvesting";return}if(t.memory.task==="harvesting"){t.store.getFreeCapacity()===0?(t.memory.task="repairing",t.say(l.repairing)):B.run(t);return}if(t.memory.task==="repairing"){const e=t.room.find(FIND_STRUCTURES,{filter:o=>o.hits<o.hitsMax||o.structureType===STRUCTURE_TOWER}).sort((o,n)=>o.structureType===STRUCTURE_TOWER&&n.structureType!==STRUCTURE_TOWER?-1:o.structureType!==STRUCTURE_TOWER&&n.structureType===STRUCTURE_TOWER?1:Math.abs(o.hits-n.hits)>1e3?o.hits-n.hits:0);if(!e.length)return;const r=e[0];if(!r.pos.isNearTo(t)){t.moveTo(r,{visualizePathStyle:{stroke:"#ffffff"}});return}if(r.structureType===STRUCTURE_TOWER&&r.store.getFreeCapacity(RESOURCE_ENERGY)>0)t.transfer(r,RESOURCE_ENERGY)===OK&&f(5,()=>t.say(l.transferring));else switch(t.repair(r)){case ERR_NOT_IN_RANGE:{t.moveTo(e[0],{visualizePathStyle:{stroke:"#ffffff"}});break}case OK:{f(10,()=>t.say(l.repairing),{time:t.ticksToLive});break}}}},q=(t,e={})=>M.create({baseId:t,body:[WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE],role:"repairer",opts:{memory:{task:"repairing"}},...e}),J={run:X,create:q},Q=t=>{if(t.memory.task==="upgrading"&&t.store[RESOURCE_ENERGY]===0){t.say(l.harvesting),t.memory.task="harvesting";return}if(t.memory.task==="harvesting"){t.store.getFreeCapacity()===0?(t.memory.task="upgrading",t.say(l.upgrading)):B.run(t);return}if(t.memory.task==="upgrading"){const e=t.room.controller;if(!e)return;switch(t.upgradeController(e)){case ERR_NOT_IN_RANGE:{t.moveTo(e,{visualizePathStyle:{stroke:"#ffffff"}});break}case OK:{f(10,()=>t.say(l.upgrading),{time:t.ticksToLive});break}}return}},Z=(t,e={})=>M.create({baseId:t,body:[WORK,CARRY,CARRY,MOVE,MOVE],role:"upgrader",opts:{memory:{task:"upgrading"}},...e}),ee={run:Q,create:Z},P={upgrader:ee,repairer:J};class w{constructor(e){C(this,"role");this.role=e}getEnergyFromStore(e,r){var n,R;let o=null;if(r.length===1){const[a]=r;a&&(o=x(e,a,!0))}else{const a=[];for(const i of r){const m=(R=(n=x(e,i,!1))==null?void 0:n.filter(u=>u!==null))!=null?R:[];for(const u of m)u&&a.push(u)}let s=[];if(s=a.filter(i=>i instanceof Resource&&i.resourceType===RESOURCE_ENERGY||i instanceof Ruin||i instanceof Tombstone),s.length>0&&(o=e.pos.findClosestByRange(s)),o||(s=a.filter(i=>i instanceof StructureContainer&&i.store[RESOURCE_ENERGY]>0||i instanceof StructureStorage&&i.store[RESOURCE_ENERGY]>0),s.length>0&&(o=e.pos.findClosestByRange(s))),!o){const i=a.filter(u=>u instanceof Creep&&u.memory&&u.memory.role==="miner"&&u.store[RESOURCE_ENERGY]>0),m=i.filter(u=>u.store.getFreeCapacity(RESOURCE_ENERGY)===0);m.length>0?o=e.pos.findClosestByRange(m):i.length>0&&(o=e.pos.findClosestByRange(i))}o||(s=a.filter(i=>i instanceof Source),s.length>0&&(o=e.pos.findClosestByRange(s))),o||(s=a.filter(i=>i instanceof Mineral||i instanceof Deposit),s.length>0&&(o=e.pos.findClosestByRange(s)))}if(o){if(!o.pos.isNearTo(e.pos)){e.moveTo(o,{visualizePathStyle:{stroke:"#ffffff"}});return}if(o instanceof Creep&&o.memory.role==="miner")return;if(o instanceof Source||o instanceof Mineral){e.harvest(o),f(10,()=>e.say(l.harvesting),{time:e.ticksToLive});return}if(o instanceof Ruin||o instanceof Tombstone){e.withdraw(o,RESOURCE_ENERGY),f(10,()=>e.say(l.withdrawing),{time:e.ticksToLive});return}if(o instanceof StructureStorage||o instanceof StructureContainer){e.withdraw(o,RESOURCE_ENERGY),f(10,()=>e.say(l.withdrawing),{time:e.ticksToLive});return}if(o instanceof Resource){e.pickup(o),f(10,()=>e.say(l.picking),{time:e.ticksToLive});return}}}}const D=[STRUCTURE_EXTENSION,STRUCTURE_TOWER,STRUCTURE_WALL,STRUCTURE_RAMPART,STRUCTURE_ROAD,STRUCTURE_CONTAINER],N=class N extends w{constructor(){super(N.role)}create(e){const{baseId:r=S.MainBase,body:o,name:n,memoryRoleOpts:R={role:"builder",task:"harvesting"}}=e,a=n!=null?n:`${this.role}-${Game.time}`;return Game.spawns[r].spawnCreep(o,a,{memory:R})}run(e){if(e.store[RESOURCE_ENERGY]===0&&e.memory.task!=="harvesting"&&(e.memory.task="harvesting"),e.store.getFreeCapacity()===0&&e.memory.task==="harvesting"&&(e.memory.task="building"),e.memory.task==="harvesting"){this.getEnergyFromStore(e,["resource","ruin","tombstone","storage","container","miner","source"]);return}this.roleTask(e)}roleTask(e){const r=e.room.find(FIND_MY_CONSTRUCTION_SITES).sort((o,n)=>{const R=D.indexOf(o.structureType),a=D.indexOf(n.structureType);return R-a});if(r.length>0)switch(e.memory.task==="repairing"&&(e.memory.task="building"),e.build(r[0])){case ERR_NOT_IN_RANGE:{e.moveTo(r[0],{visualizePathStyle:{stroke:"#ffffff"}});break}default:{f(10,()=>e.say(l.building),{time:e.ticksToLive});break}}else e.memory.task="repairing",this.roleTask2(e)}roleTask2(e){}};C(N,"role","builder");let G=N;const te=new G,k=[STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_CONTAINER,STRUCTURE_STORAGE],_=class _ extends w{constructor(){super(_.role);C(this,"create",r=>{const{baseId:o=S.MainBase,body:n,name:R,memoryRoleOpts:a={role:"harvester",task:"harvesting"}}=r,s=R!=null?R:`${this.role}-${Game.time}`;return Game.spawns[o].spawnCreep(n,s,{memory:a})})}run(r){if(r.store[RESOURCE_ENERGY]===0&&r.memory.task==="transferring"&&(r.memory.task="harvesting"),r.store.getFreeCapacity()===0&&r.memory.task==="harvesting"&&(r.memory.task="transferring"),r.memory.task==="harvesting"){this.harvestTask(r);return}this.roleTask(r)}roleTask(r){const o=r.room.find(FIND_MY_STRUCTURES,{filter:n=>k.includes(n.structureType)&&"store"in n&&n.store.getFreeCapacity(RESOURCE_ENERGY)>0}).sort((n,R)=>{const a=k.indexOf(n.structureType),s=k.indexOf(R.structureType);return a-s});if(o.length>0)switch(r.transfer(o[0],RESOURCE_ENERGY)){case ERR_NOT_IN_RANGE:{r.moveTo(o[0],{visualizePathStyle:{stroke:"#ffffff"}});break}default:f(10,()=>r.say(l.transferring),{time:r.ticksToLive})}}harvestTask(r){this.getEnergyFromStore(r,["resource","ruin","tombstone","miner"])}};C(_,"role","harvester");let I=_;const oe=new I,v=class v extends w{constructor(){super(v.role)}create(e){const{baseId:r=S.MainBase,body:o,name:n,memoryRoleOpts:R={role:this.role,task:"moving"}}=e,a=n!=null?n:`${this.role}-${Game.time}`;return Game.spawns[r].spawnCreep(o,a,{memory:R})}run(e){e.memory.task==="moving"?this.moveTask(e):this.roleTask(e)}moveTask(e){var o;let r=null;e.memory.targetId?r=Game.getObjectById(e.memory.targetId):r=(o=Memory.sources.Source.map(R=>Game.getObjectById(R)).filter(R=>R!==null).find(R=>R.pos.findInRange(FIND_MY_CREEPS,1,{filter:s=>s.memory.role==="miner"&&s.name!==e.name}).length===0))!=null?o:null,r&&(e.pos.isNearTo(r)?(e.memory.task="mining",e.memory.targetId=r.id):(e.moveTo(r,{visualizePathStyle:{stroke:"#ffffff"}}),f(10,()=>e.say(l.moving))))}roleTask(e){const r=e.pos.findInRange(FIND_MY_CREEPS,1,{filter:o=>o.memory.role!=="miner"&&o.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(r.length>0&&(e.transfer(r[0],RESOURCE_ENERGY),f(10,()=>e.say(l.transferring))),e.memory.targetId){const o=Game.getObjectById(e.memory.targetId);o&&(e.harvest(o),f(10,()=>e.say(l.mining)));return}e.memory.task="moving"}};C(v,"role","miner");let Y=v;const re=new Y,T={harvester:oe,builder:te,miner:re};class ne{constructor(e){C(this,"tower");this.tower=e}run(){this.tower.store[RESOURCE_ENERGY]!==0&&(this.healFriendlyCreeps(),this.attackHostileCreeps(),this.repairStructures())}attackHostileCreeps(){const e=this.tower.room.find(FIND_HOSTILE_CREEPS,{filter:r=>r.body.some(o=>o.type===ATTACK||o.type===RANGED_ATTACK)});if(e.length>0){const r=e.sort((o,n)=>o.hits-o.hitsMax)[0];this.tower.attack(r)}}healFriendlyCreeps(){const e=this.tower.room.find(FIND_MY_CREEPS,{filter:r=>r.hits<r.hitsMax});if(e.length>0){const r=e.sort((o,n)=>o.hits-n.hits)[0];this.tower.heal(r)}}repairStructures(){const e=this.tower.room.find(FIND_STRUCTURES,{filter:r=>r.hits<1e4&&r.hits<r.hitsMax});if(e.length>0){const r=e.sort((o,n)=>o.hits-n.hits)[0];this.tower.repair(r)}}}const se=t=>{t.find(FIND_MY_STRUCTURES,{filter:r=>r.structureType===STRUCTURE_TOWER}).forEach(r=>{new ne(r).run()})},ie=()=>{ae(),Re(),ue()},ae=()=>{for(let t in Memory.creeps)Game.creeps[t]||(delete Memory.creeps[t],console.log("Clearing non-existing creep memory:",t))},ue=()=>{var e;const t={harvester:0,builder:0,upgrader:0,miner:0,minerStore:0,repairer:0};for(const r of Object.values(Game.creeps))r.memory.role&&(t[r.memory.role]=((e=t[r.memory.role])!=null?e:0)+1);Memory.creepsCount=t},Re=()=>{me()},me=()=>{var n,R;const t=Game.rooms[A.MainRoom];if(!t)return;if(!((n=Memory.sources)!=null&&n.Source)){const a=t.find(FIND_SOURCES);h.set(Memory,"sources.Source",a.map(s=>s.id))}if(!((R=Memory.sources)!=null&&R.Mineral)){const a=t.find(FIND_MINERALS);h.set(Memory,"sources.Mineral",a.map(s=>s.id))}const e=t.find(FIND_DROPPED_RESOURCES);h.set(Memory,"sources.Resource",e.map(a=>a.id));const r=t.find(FIND_RUINS);h.set(Memory,"sources.Ruin",r.map(a=>a.id));const o=t.find(FIND_TOMBSTONES);h.set(Memory,"sources.Tombstone",o.map(a=>a.id))},le=()=>{f(10,fe)},fe=()=>{const t=Object.values(Game.spawns);for(const e of t)e.spawning?e.room.visual.text(`Spawning:${e.spawning.name}`,{...e.pos,y:e.pos.y-1},{font:.5,color:"#00ff00",stroke:"#000000",strokeWidth:.1}):e.room.visual.text(`${e.store[RESOURCE_ENERGY]}`,{...e.pos,y:e.pos.y+1},{font:.5,color:"#00ff00",stroke:"#000000",strokeWidth:.1})},ye={roleMonitor:{harvester:{count:4,body:[WORK,WORK,CARRY,MOVE]},builder:{count:3,body:[WORK,CARRY,CARRY,MOVE,MOVE]},upgrader:{count:3,body:[WORK,CARRY,CARRY,MOVE,MOVE]},miner:{count:0,body:[WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,MOVE]}}},Ee={roleMonitor:{harvester:{count:5,body:y([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}])},builder:{count:8,body:y([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}])},upgrader:{count:5,body:y([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}])}}},ce={roleMonitor:{harvester:{count:6,body:y([{body:CARRY,count:7},{body:MOVE,count:4}])},builder:{count:2,body:y([{body:WORK,count:2},{body:CARRY,count:4},{body:MOVE,count:3}])},upgrader:{count:10,body:y([{body:WORK,count:3},{body:CARRY,count:2},{body:MOVE,count:3}])},repairer:{count:1,body:y([{body:WORK,count:2},{body:CARRY,count:4},{body:MOVE,count:3}])}}},de={roleMonitor:{harvester:{count:4,body:y([{body:CARRY,count:11},{body:MOVE,count:5}])},builder:{count:3,body:y([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])},upgrader:{count:6,body:y([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])},repairer:{count:5,body:y([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])}}},ge={roleMonitor:{harvester:{count:5,body:y([{body:CARRY,count:11},{body:MOVE,count:5}])},builder:{count:4,body:y([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])},upgrader:{count:4,body:y([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])},repairer:{count:2,body:y([{body:WORK,count:3},{body:CARRY,count:5},{body:MOVE,count:5}])}}},Se=[Ee,ce,de,ge],Ce=t=>{for(let e=t;e>=1;e--){const r=Se[e-1];if(r)return r}return ye},Oe=()=>{he()},he=()=>{var o,n,R,a;const t=new Map([["miner",0],["harvester",0],["minerStore",0],["builder",0],["upgrader",0],["repairer",0]]);for(let s in Game.creeps){const i=Game.creeps[s];i.memory.role&&(t.set(i.memory.role,((o=t.get(i.memory.role))!=null?o:0)+1),f(10,()=>M.getVisualStatus(i)))}const e=Ce((R=(n=Game.rooms[A.MainRoom].controller)==null?void 0:n.level)!=null?R:0),r=t.entries();for(let[s,i]of r)if(e.roleMonitor[s]&&i<e.roleMonitor[s].count){f(10,()=>{var E;const m=((E=e.roleMonitor[s])==null?void 0:E.body)||[],u={};for(const c of m)u[c]=(u[c]||0)+1;console.log(`${s} 数量不足`,JSON.stringify(u))}),["harvester","builder"].includes(s)?(a=T[s])==null||a.create({body:e.roleMonitor[s].body,memoryRoleOpts:{role:s,task:"harvesting"}}):utils.role[s].create(S.MainBase,{body:e.roleMonitor[s].body});break}},K=["FixedMiner1","FixedMiner2"],b=["MinMiner","MinMiner2"],Te=()=>{be()&&Ne()&&Oe()},be=()=>{var e;const t=[...b.map(r=>({name:r,role:"miner"})),{name:"MinHarvester",role:"harvester"},{name:"MinHarvester2",role:"harvester"},{name:"MinUpgrader",role:"upgrader"}];for(const r of t){if(b.includes(r.name)&&Memory.creepsCount.miner>=2||r.name.startsWith("MinHarvester")&&Memory.creepsCount.harvester>=2||r.name==="MinUpgrader"&&Memory.creepsCount.upgrader>=1)continue;if(!Game.creeps[r.name])if(b.includes(r.name))(e=T.miner)==null||e.create({body:y([{body:WORK,count:2},{body:CARRY,count:1},{body:MOVE,count:1}]),name:r.name,memoryRoleOpts:{role:"miner",task:"moving"}});else return Game.spawns[S.MainBase].spawnCreep(y([{body:CARRY,count:4},{body:MOVE,count:2}]),r.name,{memory:{role:r.role,task:r.role==="miner"?"moving":"harvesting"}}),f(10,()=>console.log(`MinCreepGroup中缺少: ${r.name}, 等待孵化...`)),!1}return!0},Ne=()=>{var e;if(K.every(r=>Game.creeps[r]))for(const r of b)Game.creeps[r]&&Game.creeps[r].suicide();const t=K.map(r=>({name:r}));for(const r of t){const o=Game.creeps[r.name];if(o!=null&&o.ticksToLive&&o.ticksToLive<100&&Game.spawns[S.MainBase].store.getFreeCapacity(RESOURCE_ENERGY)>0)return f(10,()=>console.log(`Miner ${r.name} 即将死亡，需要补充, 存储能量`)),!1;if(!o)return(e=T.miner)==null||e.create({body:y([{body:WORK,count:6},{body:CARRY,count:1},{body:MOVE,count:3}]),name:r.name,memoryRoleOpts:{role:"miner",task:"moving"}}),f(10,()=>console.log(`缺少: ${r.name}, 等待孵化...`)),!1}return!0},_e=()=>{le(),ie(),Te()},ve=()=>{var t,e,r,o,n;for(let R in Game.rooms){const a=Game.rooms[R];if((t=a.controller)!=null&&t.my){_e();for(let s in Game.creeps){let i=Game.creeps[s];i.memory.role=="harvester"&&((e=T.harvester)==null||e.run(i)),i.memory.role=="builder"&&((r=T.builder)==null||r.run(i)),i.memory.role=="miner"&&((o=T.miner)==null||o.run(i)),i.memory.role&&((n=P[i.memory.role])==null||n.run(i))}se(a)}}};module.exports={loop:ve};global.utils={role:P};
